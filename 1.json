{
    "file_path": "security_data/gpt3_security_vulnerability_scanner-main/Unsafe Deserialization/pickle2.py",
    "vulnerability": "Answer: No vulnerabilities detected.",
    "source code": "from __future__ import unicode_literals\nfrom flask import Flask, request, make_response, redirect, url_for, session\nfrom flask import render_template, flash, redirect, url_for, request\nfrom werkzeug.security import safe_str_cmp\nfrom base64 import b64decode as b64d\nfrom base64 import b64encode as b64e\nfrom hashlib import sha256\nfrom cStringIO import StringIO\nimport random\nimport string\n\nimport os\nimport sys\nimport subprocess\nimport commands\nimport pickle\nimport cPickle\nimport marshal\nimport os.path\nimport filecmp\nimport glob\nimport linecache\nimport shutil\nimport dircache\nimport io\nimport timeit\nimport popen2\nimport code\nimport codeop\nimport pty\nimport posixfile\n\nSECRET_KEY = 'you will never guess'\n\nif not os.path.exists('.secret'):\n    with open(\".secret\", \"w\") as f:\n        secret = ''.join(random.choice(string.ascii_letters + string.digits)\n                         for x in range(4))\n        f.write(secret)\nwith open(\".secret\", \"r\") as f:\n    cookie_secret = f.read().strip()\n\napp = Flask(__name__)\napp.config.from_object(__name__)\n\nblack_type_list = [eval, execfile, compile, open, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.open, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,\n                   os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.open, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.open, posixfile.fileopen]\n\n\n@app.before_request\ndef count():\n    session['cnt'] = 0\n\n\n@app.route('/')\ndef home():\n    remembered_str = 'Hello, here\\'s what we remember for you. And you can change, delete or extend it.'\n    new_str = 'Hello fellow zombie, have you found a tasty brain and want to remember where? Go right here and enter it:'\n    location = getlocation()\n    if location == False:\n        return redirect(url_for(\"clear\"))\n    return render_template('index.html', txt=remembered_str, location=location)\n\n\n@app.route('/clear')\ndef clear():\n    flash(\"Reminder cleared!\")\n    response = redirect(url_for('home'))\n    response.set_cookie('location', max_age=0)\n    return response\n\n\n@app.route('/reminder', methods=['POST', 'GET'])\ndef reminder():\n    if request.method == 'POST':\n        location = request.form[\"reminder\"]\n        if location == '':\n            flash(\"Message cleared, tell us when you have found more brains.\")\n        else:\n            flash(\"We will remember where you find your brains.\")\n        location = b64e(pickle.dumps(location))\n        cookie = make_cookie(location, cookie_secret)\n        response = redirect(url_for('home'))\n        response.set_cookie('location', cookie)\n        return response\n    location = getlocation()\n    if location == False:\n        return redirect(url_for(\"clear\"))\n    return render_template('reminder.html')\n\n\nclass FilterException(Exception):\n    def __init__(self, value):\n        super(FilterException, self).__init__(\n            'The callable object {value} is not allowed'.format(value=str(value)))\n\n\nclass TimesException(Exception):\n    def __init__(self):\n        super(TimesException, self).__init__(\n            'Call func too many times!')\n\n\ndef _hook_call(func):\n    def wrapper(*args, **kwargs):\n        session['cnt'] += 1\n        print session['cnt']\n        print args[0].stack\n        for i in args[0].stack:\n            if i in black_type_list:\n                raise FilterException(args[0].stack[-2])\n            if session['cnt'] > 4:\n                raise TimesException()\n        return func(*args, **kwargs)\n    return wrapper\n\n\ndef loads(strs):\n    reload(pickle)\n    files = StringIO(strs)\n    unpkler = pickle.Unpickler(files)\n    unpkler.dispatch[pickle.REDUCE] = _hook_call(\n        unpkler.dispatch[pickle.REDUCE])\n    return unpkler.load()\n\n\ndef getlocation():\n    cookie = request.cookies.get('location')\n    if not cookie:\n        return ''\n    (digest, location) = cookie.split(\"!\")\n    if not safe_str_cmp(calc_digest(location, cookie_secret), digest):\n        flash(\"Hey! This is not a valid cookie! Leave me alone.\")\n        return False\n    location = loads(b64d(location))\n    return location\n\n\ndef make_cookie(location, secret):\n    return \"%s!%s\" % (calc_digest(location, secret), location)\n\n\ndef calc_digest(location, secret):\n    return sha256(\"%s%s\" % (location, secret)).hexdigest()\n\n\nif __name__ == '__main__':\n    app.run(host=\"0.0.0.0\", port=5051)\n",
    "language": "python",
    "cwe_identifier": [
        "CWE-338"
    ],
    "pattern_desc": [
        "The default random module in Python should not be used for cryptographic applications. Prefer the secrets module for these uses (https://docs.python.org/3/library/random.html)."
    ],
    "line_number": [
        37
    ],
    "line_text": [
        "        secret = ''.join(random.choice(string.ascii_letters + string.digits)"
    ],
    "pattern_id": [
        "insecure_code_detector.rules.semgrep.python.insecure-crypto-prng-random"
    ],
    "rule": [
        null
    ],
    "label": 0
}